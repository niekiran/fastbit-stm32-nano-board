#include "font.h"
#include "main.h"

#ifndef INC_GC9A01A_STM32_PARALLEL8_H_
#define INC_GC9A01A_STM32_PARALLEL8_H_

// GC9A01A commands
#define GC9A01A_WIDTH     240
#define GC9A01A_HEIGHT    240

#define GC9A01A_NOP       0x00
#define GC9A01A_SWRESET   0x01
#define GC9A01A_RDDID     0x04
#define GC9A01A_RDDST     0x09

#define GC9A01A_SLPIN     0x10
#define GC9A01A_SLPOUT    0x11
#define GC9A01A_PTLON     0x12
#define GC9A01A_NORON     0x13

#define GC9A01A_INVOFF    0x20
#define GC9A01A_INVON     0x21
#define GC9A01A_DISPOFF   0x28
#define GC9A01A_DISPON    0x29

#define GC9A01A_CASET     0x2A
#define GC9A01A_RASET     0x2B
#define GC9A01A_RAMWR     0x2C
#define GC9A01A_RAMRD     0x2E

#define GC9A01A_MADCTL    0x36
#define GC9A01A_COLMOD    0x3A

// Color definitions
#define GC9A01A_COLOR_BLACK       0x0000
#define GC9A01A_COLOR_NAVY        0x000F
#define GC9A01A_COLOR_DARKGREEN   0x03E0
#define GC9A01A_COLOR_DARKCYAN    0x03EF
#define GC9A01A_COLOR_MAROON      0x7800
#define GC9A01A_COLOR_PURPLE      0x780F
#define GC9A01A_COLOR_OLIVE       0x7BE0
#define GC9A01A_COLOR_LIGHTGREY   0xC618
#define GC9A01A_COLOR_DARKGREY    0x7BEF
#define GC9A01A_COLOR_BLUE        0x001F
#define GC9A01A_COLOR_GREEN       0x07E0
#define GC9A01A_COLOR_CYAN        0x07FF
#define GC9A01A_COLOR_RED         0xF800
#define GC9A01A_COLOR_MAGENTA     0xF81F
#define GC9A01A_COLOR_YELLOW      0xFFE0
#define GC9A01A_COLOR_WHITE       0xFFFF
#define GC9A01A_COLOR_ORANGE      0xFD20
#define GC9A01A_COLOR_GREENYELLOW 0xAFE5
#define GC9A01A_COLOR_PINK        0xF81F

/*************************** Pin configuration START ************************/

#define HIGH_16(x)                      ((((uint16_t)x) >> 8U) & 0xFFU)
#define LOW_16(x)                       ((((uint16_t)x) >> 0U) & 0xFFU)

#define MADCTL_MY  0x80
#define MADCTL_MX  0x40
#define MADCTL_MV  0x20
#define MADCTL_ML  0x10
#define MADCTL_RGB 0x00
#define MADCTL_BGR 0x08
#define MADCTL_MH  0x04
/*************************** Pin configuration END ************************/
#define GC9A01A_BL_ACTIVE       HAL_GPIO_WritePin(BL_A_GPIO_Port, BL_A_Pin, GPIO_PIN_SET)

#define GC9A01A_RD_ACTIVE       HAL_GPIO_WritePin(LCD_RDX_GPIO_Port, LCD_RDX_Pin, GPIO_PIN_RESET)
#define GC9A01A_RD_IDLE         HAL_GPIO_WritePin(LCD_RDX_GPIO_Port, LCD_RDX_Pin, GPIO_PIN_SET)

#define GC9A01A_WR_ACTIVE       HAL_GPIO_WritePin(WRD_GPIO_Port, WRD_Pin, GPIO_PIN_RESET)
#define GC9A01A_WR_IDLE         HAL_GPIO_WritePin(WRD_GPIO_Port, WRD_Pin, GPIO_PIN_SET)

#define GC9A01A_DC_CMD          HAL_GPIO_WritePin(DCX_GPIO_Port, DCX_Pin, GPIO_PIN_RESET)
#define GC9A01A_DC_DAT          HAL_GPIO_WritePin(DCX_GPIO_Port, DCX_Pin, GPIO_PIN_SET)

#define GC9A01A_CS_ACTIVE       HAL_GPIO_WritePin(LCD_CSX_GPIO_Port, LCD_CSX_Pin, GPIO_PIN_RESET)
#define GC9A01A_CS_IDLE         HAL_GPIO_WritePin(LCD_CSX_GPIO_Port, LCD_CSX_Pin, GPIO_PIN_SET)

#define GC9A01A_RST_ACTIVE      HAL_GPIO_WritePin(LCD_RST_GPIO_Port, LCD_RST_Pin, GPIO_PIN_RESET)
#define GC9A01A_RST_IDLE        HAL_GPIO_WritePin(LCD_RST_GPIO_Port, LCD_RST_Pin, GPIO_PIN_SET)

#define GC9A01A_WR_STROBE       { GC9A01A_WR_ACTIVE;  GC9A01A_WR_IDLE; }
#define GC9A01A_RD_STROBE       { GC9A01A_RD_ACTIVE;  GC9A01A_RD_IDLE; }

#define GC9A01A_TE_IDLE         HAL_GPIO_WritePin(LCD_TE_GPIO_Port, LCD_TE_Pin, GPIO_PIN_RESET)
/*
#define GC9A01A_WRITE_8BIT(d) { \
  GPIOA->BSRR = 0b0000011000000000 << 16; \
  GPIOB->BSRR = 0b1111110000000000 << 16; \
  GPIOA->BSRR = (((d) & (1<<0)) << 10) \
              | (((d) & (1<<1)) << 8); \
  GPIOB->BSRR = (((d) & (1<<2)) << 13) \
              | (((d) & (1<<3)) << 11) \
               | (((d) & (1<<4)) << 9) \
               | (((d) & (1<<5)) << 7) \
               | (((d) & (1<<6)) << 5) \
               | (((d) & (1<<7)) << 3); \
               GC9A01A_WR_STROBE; \
}*/

#define GC9A01A_WRITE_8BIT(d)   { \
    HAL_GPIO_WritePin(BD0_GPIO_Port, BD0_Pin, (d& (1 << 0)) >> 0);\
    HAL_GPIO_WritePin(BD1_GPIO_Port, BD1_Pin, (d& (1 << 1)) >> 1);\
    HAL_GPIO_WritePin(BD2_GPIO_Port, BD2_Pin, (d& (1 << 2)) >> 2);\
    HAL_GPIO_WritePin(BD3_GPIO_Port, BD3_Pin, (d& (1 << 3)) >> 3);\
    HAL_GPIO_WritePin(BD4_GPIO_Port, BD4_Pin, (d& (1 << 4)) >> 4);\
    HAL_GPIO_WritePin(BD5_GPIO_Port, BD5_Pin, (d& (1 << 5)) >> 5);\
    HAL_GPIO_WritePin(BD6_GPIO_Port, BD6_Pin, (d& (1 << 6)) >> 6);\
    HAL_GPIO_WritePin(BD7_GPIO_Port, BD7_Pin, (d& (1 << 7)) >> 7);\
    GC9A01A_WR_STROBE; \
}

#define GC9A01A_READ_8BIT(d)    { \
    d = (uint8_t)( \
        (HAL_GPIO_ReadPin(BD0_GPIO_Port, BD0_Pin) ? 0x01 : 0x00) | \
        (HAL_GPIO_ReadPin(BD1_GPIO_Port, BD1_Pin) ? 0x02 : 0x00) | \
        (HAL_GPIO_ReadPin(BD2_GPIO_Port, BD2_Pin) ? 0x04 : 0x00) | \
        (HAL_GPIO_ReadPin(BD3_GPIO_Port, BD3_Pin) ? 0x08 : 0x00) | \
        (HAL_GPIO_ReadPin(BD4_GPIO_Port, BD4_Pin) ? 0x10 : 0x00) | \
        (HAL_GPIO_ReadPin(BD5_GPIO_Port, BD5_Pin) ? 0x20 : 0x00) | \
        (HAL_GPIO_ReadPin(BD6_GPIO_Port, BD6_Pin) ? 0x40 : 0x00) | \
        (HAL_GPIO_ReadPin(BD7_GPIO_Port, BD7_Pin) ? 0x80 : 0x00) \
    ); \
    GC9A01A_RD_STROBE; \
}


/*
 * Inline function to send 8 bit command to the display
 * User need not call it
 */
//__attribute__((always_inline)) static inline void _gc9_write_command_8bit(uint8_t cmd)
//{
//    //CS_ACTIVE;
//    GC9A01A_DC_CMD;
//    GC9A01A_WRITE_8BIT(cmd);
//
//}
//
///*
// * Inline function to send 8 bit data to the display
// * User need not call it
// */
//__attribute__((always_inline)) static inline  void _gc9_write_data_8bit(uint8_t dat)
//{
//    //CS_ACTIVE;
//  GC9A01A_DC_DAT;
//    GC9A01A_WRITE_8BIT(dat);
//}
void _gc9_write_command_8bit(uint8_t cmd);
void gc9a01a_write_data(uint8_t *buffer, uint32_t len);
void GC9A01A_SendCommand(uint8_t cmd);
void GC9A01A_SendData(uint8_t data);
void GC9A01A_Init();
void gc9a01a_hw_reset();
void GC9A01A_Reset(void);
void gc9a01a_WriteChar_trans(uint16_t x, uint16_t y, char ch, FontDef font, uint16_t color) ;
void gc9a01a_WriteChar(uint16_t x, uint16_t y, char ch, FontDef font, uint16_t color, uint16_t bgcolor);
void gc9a01a_WriteString_trans(uint16_t x, uint16_t y, const char* str, FontDef font, uint16_t color) ;
void gc9a01a_WriteString(uint16_t x, uint16_t y, const char* str, FontDef font, uint16_t color, uint16_t bgcolor);
void gc9a01a_rect_fill(uint16_t color, uint32_t x_start, uint32_t x_width,uint32_t y_start,uint32_t y_height);
void gc9a01a_fill_rectangle(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color);
void gc9a01a_fill_color(uint16_t color, uint32_t len);
void gc9a01a_fill_color_test(uint16_t color, uint32_t len);
void gc9a01a_draw_image(uint16_t x, uint16_t y, uint16_t w, uint16_t h, const uint16_t* data);
void gc9a01a_FillRectangle(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color);
void gc9a01a_rect_fill(uint16_t color, uint32_t x_start, uint32_t x_width,uint32_t y_start,uint32_t y_height);
void gc9a01a_fill_rect1(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color);
void gc9a01a_fill_screen(uint16_t color);
void GC9A01A_DrawPixel(uint16_t x, uint16_t y, uint16_t color);
void GC9A01A_FillScreen(uint16_t color);
void GC9A01A_DrawBitmap(uint16_t x, uint16_t y, const uint8_t *bitmap, uint16_t w, uint16_t h);
void GC9A01A_SetRotation(uint8_t m);

#endif /* INC_GC9A01A_STM32_PARALLEL8_H_ */
