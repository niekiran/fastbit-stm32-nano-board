
#include <stdlib.h>
#include "GC9A01A.h"

// TFT width and height default global variables
uint16_t gc9a01a_tftwidth = 240;
uint16_t gc9a01a_tftheight = 240;

/**
 * Set an area for drawing on the display with start row, col and end row, col.
 * User don't need to call it usually, call it only before some functions who don't call it by default.
 * @param x1 start column address.
 * @param y1 start row address.
 * @param x2 end column address.
 * @param y2 end row address.
 */
void gc9a01a_set_address_window(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2) {
    // Send commands to set column address (x2 to x2)
    GC9A01A_DC_CMD;
    GC9A01A_WRITE_8BIT(GC9A01A_CASET); // Column address set command
    GC9A01A_DC_DAT;
    GC9A01A_WRITE_8BIT((uint8_t)(x1 >> 8));
    GC9A01A_WRITE_8BIT((uint8_t)x1);
    GC9A01A_WRITE_8BIT((uint8_t)(x2 >> 8));
    GC9A01A_WRITE_8BIT((uint8_t)x2);

    // Send commands to set row address (y2 to y2)
    GC9A01A_DC_CMD;
    GC9A01A_WRITE_8BIT(GC9A01A_PASET); // Row address set command
    GC9A01A_DC_DAT;
    GC9A01A_WRITE_8BIT((uint8_t)(y1 >> 8));
    GC9A01A_WRITE_8BIT((uint8_t)y1);
    GC9A01A_WRITE_8BIT((uint8_t)(y2 >> 8));
    GC9A01A_WRITE_8BIT((uint8_t)y2);

    // Send command to write to RAM
    GC9A01A_DC_CMD;
    GC9A01A_WRITE_8BIT(0x2C); // Write to RAM command
    GC9A01A_DC_DAT;
}

void _gc9_write_command_8bit(uint8_t cmd)
{
    //CS_ACTIVE;
    GC9A01A_DC_CMD;
    GC9A01A_WRITE_8BIT(cmd);

}

/*
 * Inline function to send 8 bit data to the display
 * User need not call it
 */
void _gc9_write_data_8bit(uint8_t dat)
{
    //CS_ACTIVE;
  GC9A01A_DC_DAT;
    GC9A01A_WRITE_8BIT(dat);
}



/**
 * Fill the entire display (screen) with `color`
 * @param color 16-bit RGB565 color
 */
void gc9a01a_fill_screen(uint16_t color)
{
  gc9a01a_set_address_window(0, 0, (uint16_t)gc9a01a_tftwidth, (uint16_t)gc9a01a_tftheight);

  gc9a01a_fill_color(color, (uint32_t)gc9a01a_tftwidth * (uint32_t)gc9a01a_tftheight);
  //gc9a01a_fill_color_test(color, (uint32_t)gc9a01a_tftwidth * (uint32_t)gc9a01a_tftheight );
}

void gc9a01a_rect_fill(uint16_t color, uint32_t x_start, uint32_t x_width,uint32_t y_start,uint32_t y_height)
{
  gc9a01a_set_address_window(x_start, y_start, x_width, y_height);

  gc9a01a_fill_color(color, (uint16_t)x_width * (uint16_t)y_height);
  //gc9a01a_fill_color_test(color, (uint16_t)x_width * (uint16_t)y_height );
}
/**
 * Fills a rectangular area with `color`.
 * Before filling, performs area bound checking
 * @param x Start col address
 * @param y Start row address
 * @param w Width of rectangle
 * @param h Height of rectangle
 * @param color 16-bit RGB565 color
 */
void gc9a01a_fill_rect1(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color)
{
    if (x >= gc9a01a_tftwidth || y >= gc9a01a_tftheight || w == 0 || h == 0)
        return;
    if (x + w - 1 >= gc9a01a_tftwidth)
        w = gc9a01a_tftwidth - x;
    if (y + h - 1 >= gc9a01a_tftheight)
        h = gc9a01a_tftheight - y;

    gc9a01a_set_address_window(x, y, x + w - 1, y + h - 1);
    gc9a01a_fill_color(color, (uint32_t)w * (uint32_t)h);
}
//void gc9a01a_fill_rectangle(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color) {
//    // Clipping
//    if((x >= GC9A01A_WIDTH) || (y >= GC9A01A_HEIGHT)) return;
//    if((x + w - 1) >= GC9A01A_WIDTH) w = GC9A01A_WIDTH - x;
//    if((y + h - 1) >= GC9A01A_HEIGHT) h = GC9A01A_HEIGHT - y;
//
//    GC9A01A_CS_ACTIVE;
//    gc9a01a_set_address_window(x, y, x + w - 1, y + h - 1);
//
//    uint8_t data[] = { color >> 8, color & 0xFF };
//    GC9A01A_DC_DAT;
//    for(y = h; y > 0; y--) {
//        for(x = w; x > 0; x--) {
//            GC9A01A_WRITE_8BIT(data[0]);
//            GC9A01A_WR_STROBE;
//            GC9A01A_WRITE_8BIT(data[1]);
//            GC9A01A_WR_STROBE;
//        }
//    }
//
//    GC9A01A_CS_IDLE;
//}
void gc9a01a_draw_rectangle(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color) {
    if ((x >= 240) || (y >= 240)) return;
    if ((x + w - 1) >= 240) w = 240 - x;
    if ((y + h - 1) >= 240) h = 240 - y;

    gc9a01a_set_address_window(x, y, x + w - 1, y + h - 1);

    uint32_t total_pixels = w * h;
    uint8_t color_high = color >> 8;
    uint8_t color_low = color;

    for (uint32_t i = 0; i < total_pixels; i++) {
        GC9A01A_WRITE_8BIT(color_high);
        GC9A01A_WRITE_8BIT(color_low);
    }
}
void gc9a01a_WriteChar_trans(uint16_t x, uint16_t y, char ch, FontDef font, uint16_t color) {
    uint32_t i, b, j;

    gc9a01a_set_address_window(x, y, x + font.width - 1, y + font.height - 1);

    for (i = 0; i < font.height; i++) {
        b = font.data[(ch - 32) * font.height + i];
        for (j = 0; j < font.width; j++) {
            if ((b << j) & 0x8000) {
                uint8_t data[] = { color >> 8, color & 0xFF };
                GC9A01A_WRITE_8BIT(data[0]);
                GC9A01A_WRITE_8BIT(data[1]);
            } else {
                // Skip writing the background color to achieve transparency
                continue;
            }
        }
    }
}
void gc9a01a_WriteChar(uint16_t x, uint16_t y, char ch, FontDef font, uint16_t color, uint16_t bgcolor) {
    uint32_t i, b, j;

    gc9a01a_set_address_window(x, y, x + font.width - 1, y + font.height - 1);

    for (i = 0; i < font.height; i++) {
        b = font.data[(ch - 32) * font.height + i];
        for (j = 0; j < font.width; j++) {
            if ((b << j) & 0x8000) {
                uint8_t data[] = { color >> 8, color & 0xFF };
                GC9A01A_WRITE_8BIT(data[0]);
                GC9A01A_WRITE_8BIT(data[1]);
            } else {
                uint8_t data[] = { bgcolor >> 8, bgcolor & 0xFF };
                GC9A01A_WRITE_8BIT(data[0]);
                GC9A01A_WRITE_8BIT(data[1]);
            }
        }
    }
}
void gc9a01a_WriteString_trans(uint16_t x, uint16_t y, const char* str, FontDef font, uint16_t color) {

    while (*str) {
        if (x + font.width >= GC9A01A_WIDTH) {
            x = 0;
            y += font.height;
            if (y + font.height >= GC9A01A_HEIGHT) {
                break;
            }

            if (*str == ' ') {
                // skip spaces at the beginning of the new line
                str++;
                continue;
            }
        }

        gc9a01a_WriteChar_trans(x, y, *str, font, color);
        x += font.width;
        str++;
    }
}
void gc9a01a_WriteString(uint16_t x, uint16_t y, const char* str, FontDef font, uint16_t color, uint16_t bgcolor) {

    while (*str) {
        if (x + font.width >= GC9A01A_WIDTH) {
            x = 0;
            y += font.height;
            if (y + font.height >= GC9A01A_HEIGHT) {
                break;
            }

            if (*str == ' ') {
                // skip spaces at the beginning of the new line
                str++;
                continue;
            }
        }

        gc9a01a_WriteChar(x, y, *str, font, color, bgcolor);
        x += font.width;
        str++;
    }
}

//void GC9A01A_FillScreen(uint16_t color) {
//    GC9A01A_FillRectangle(0, 0, GC9A01A_WIDTH, GC9A01A_HEIGHT, color);
//}

void gc9a01a_draw_image(uint16_t x, uint16_t y, uint16_t w, uint16_t h, const uint16_t* data) {
    if ((x >= GC9A01A_WIDTH) || (y >= GC9A01A_HEIGHT)) return;
    if ((x + w - 1) >= GC9A01A_WIDTH) w = GC9A01A_HEIGHT - x;
    if ((y + h - 1) >= GC9A01A_WIDTH) h = GC9A01A_HEIGHT - y;

    gc9a01a_set_address_window(x, y, x + w - 1, y + h - 1);

    for (uint32_t i = 0; i < w * h; i++) {
        uint8_t color_high = (data[i] >> 8) & 0xFF;
        uint8_t color_low = data[i] & 0xFF;
        GC9A01A_WRITE_8BIT(color_high);
        GC9A01A_WRITE_8BIT(color_low);
    }
}


/**
 * Fills `len` number of pixels with `color`.
 * Call ili_set_address_window() before calling this function.
 * @param color 16-bit RGB565 color value
 * @param len 32-bit number of pixels
 */
void gc9a01a_fill_color(uint16_t color, uint32_t len)
{
    /*
    * Here, macros are directly called (instead of inline functions) for performance increase
    */
    uint16_t blocks = (uint16_t)(len / 64); // 64 pixels/block
    uint8_t  pass_count;
    uint8_t color_high = color >> 8;
    uint8_t color_low = color;

    GC9A01A_DC_DAT;
    // Write first pixel
    GC9A01A_WRITE_8BIT(color_high); GC9A01A_WRITE_8BIT(color_low);
    len--;

    // If higher byte and lower byte are identical,
    // just strobe the WR pin to send the previous data
    if(color_high == color_low)
    {
        while(blocks--)
        {
            // pass count = number of blocks / pixels per pass = 64 / 4
            pass_count = 16;
            while(pass_count--)
            {
              GC9A01A_WR_STROBE;
              GC9A01A_WR_STROBE;
              GC9A01A_WR_STROBE;
              GC9A01A_WR_STROBE; // 2
              GC9A01A_WR_STROBE;
              GC9A01A_WR_STROBE;
              GC9A01A_WR_STROBE;
              GC9A01A_WR_STROBE; // 4
            }
        }
        // Fill any remaining pixels (1 to 64)
        pass_count = len & 63;
        while (pass_count--)
        {
          GC9A01A_WR_STROBE; GC9A01A_WR_STROBE;
        }
    }

    // If higher and lower bytes are different, send those bytes
    else
    {
        while(blocks--)
        {
            pass_count = 16;
            while(pass_count--)
            {
                GC9A01A_WRITE_8BIT(color_high); GC9A01A_WRITE_8BIT(color_low);  GC9A01A_WRITE_8BIT(color_high); GC9A01A_WRITE_8BIT(color_low); //2
                GC9A01A_WRITE_8BIT(color_high); GC9A01A_WRITE_8BIT(color_low);  GC9A01A_WRITE_8BIT(color_high); GC9A01A_WRITE_8BIT(color_low); //4
            }
        }
        pass_count = len & 63;
        while (pass_count--)
        {
            // write here the remaining data
            GC9A01A_WRITE_8BIT(color_high); GC9A01A_WRITE_8BIT(color_low);
        }
    }
}

void gc9a01a_fill_color_test(uint16_t color, uint32_t len)
{
    uint8_t color_high = (color >> 8) & 0xFF;  // Correct extraction of high byte
    uint8_t color_low = color & 0xFF;          // Correct extraction of low byte

    GC9A01A_DC_DAT;
    // Write pixels
    while(len>0) {
        GC9A01A_WRITE_8BIT(color_high);
        GC9A01A_WR_STROBE;
        GC9A01A_WRITE_8BIT(color_low);
        GC9A01A_WR_STROBE;
        len--;
    }
}
void gc9a01a_FillRectangle(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color) {
    // clipping
    if((x >= GC9A01A_WIDTH) || (y >= GC9A01A_HEIGHT)) return;
    if((x + w - 1) >= GC9A01A_WIDTH) w = GC9A01A_WIDTH - x;
    if((y + h - 1) >= GC9A01A_HEIGHT) h = GC9A01A_HEIGHT - y;

    //gc9a01a_SetAddressWindow(x, y, x+w-1, y+h-1);
    gc9a01a_set_address_window(x, y, x+w-1, y+h-1);
    uint8_t data[] = { color >> 8, color & 0xFF };

    for(y = h; y > 0; y--) {
        for(x = w; x > 0; x--) {
            //HAL_SPI_Transmit(&gc9a01a_SPI_PORT, data, sizeof(data), HAL_MAX_DELAY);
          GC9A01A_WRITE_8BIT(data[0]);
          GC9A01A_WRITE_8BIT(data[1]);
        }
    }

}



void gc9a01a_hw_reset() {
    GC9A01A_RST_IDLE  ;
    HAL_Delay(10);
    GC9A01A_RST_ACTIVE;
    HAL_Delay(10);
    GC9A01A_RST_IDLE  ;
    HAL_Delay(10);
}

//void GC9A01A_Init()
//{
//  HAL_GPIO_WritePin(BL_A_GPIO_Port, BL_A_Pin, GPIO_PIN_SET);
//  GC9A01A_CS_ACTIVE;
//  gc9a01a_hw_reset();
//
//    _gc9_write_command_8bit(0xEF);
//    _gc9_write_data_8bit(0x03);
//    _gc9_write_data_8bit(0x80);
//    _gc9_write_data_8bit(0x02);
//
//    _gc9_write_command_8bit(0xCF);
//    _gc9_write_data_8bit(0x00);
//    _gc9_write_data_8bit(0xC1);
//    _gc9_write_data_8bit(0x30);
//
//    _gc9_write_command_8bit(0xED);
//    _gc9_write_data_8bit(0x64);
//    _gc9_write_data_8bit(0x03);
//    _gc9_write_data_8bit(0x12);
//    _gc9_write_data_8bit(0x81);
//
//    _gc9_write_command_8bit(0xE8);
//    _gc9_write_data_8bit(0x85);
//    _gc9_write_data_8bit(0x00);
//    _gc9_write_data_8bit(0x78);
//
//    _gc9_write_command_8bit(0xCB);
//    _gc9_write_data_8bit(0x39);
//    _gc9_write_data_8bit(0x2C);
//    _gc9_write_data_8bit(0x00);
//    _gc9_write_data_8bit(0x34);
//    _gc9_write_data_8bit(0x02);
//
//    _gc9_write_command_8bit(0xF7);
//    _gc9_write_data_8bit(0x20);
//
//    _gc9_write_command_8bit(0xEA);
//    _gc9_write_data_8bit(0x00);
//    _gc9_write_data_8bit(0x00);
//
//    _gc9_write_command_8bit(0xC0); // Power control 1
//    _gc9_write_data_8bit(0x23);    // VRH[5:0]
//
//    _gc9_write_command_8bit(0xC1); // Power control 2
//    _gc9_write_data_8bit(0x10);    // SAP[2:0]; BT[3:0]
//
//    _gc9_write_command_8bit(0xC5); // VCM control 1
//    _gc9_write_data_8bit(0x3e);
//    _gc9_write_data_8bit(0x28);
//
//    _gc9_write_command_8bit(0xC7); // VCM control 2
//    _gc9_write_data_8bit(0x86);
//
//    _gc9_write_command_8bit(0x36); // Memory Access Control
//    _gc9_write_data_8bit(0x48);    // Rotation 0 (landscape mode)
//
//    _gc9_write_command_8bit(0x3A); // Pixel format
//    _gc9_write_data_8bit(0x05);
//
//    _gc9_write_command_8bit(0xB1); // Frame rate control
//    _gc9_write_data_8bit(0x00);
//    _gc9_write_data_8bit(0x1B);    // 70Hz
//
//    _gc9_write_command_8bit(0xB6); // Display function control
//    _gc9_write_data_8bit(0x0A);
//    _gc9_write_data_8bit(0x82);
//    _gc9_write_data_8bit(0x27);
//
//    _gc9_write_command_8bit(0xF2); // 3Gamma function disable
//    _gc9_write_data_8bit(0x00);
//
//    _gc9_write_command_8bit(0x26); // Gamma curve selected
//    _gc9_write_data_8bit(0x01);
//
//    _gc9_write_command_8bit(0xE0); // Set Gamma
//    _gc9_write_data_8bit(0x0F);
//    _gc9_write_data_8bit(0x31);
//    _gc9_write_data_8bit(0x2B);
//    _gc9_write_data_8bit(0x0C);
//    _gc9_write_data_8bit(0x0E);
//    _gc9_write_data_8bit(0x08);
//    _gc9_write_data_8bit(0x4E);
//    _gc9_write_data_8bit(0xF1);
//    _gc9_write_data_8bit(0x37);
//    _gc9_write_data_8bit(0x07);
//    _gc9_write_data_8bit(0x10);
//    _gc9_write_data_8bit(0x03);
//    _gc9_write_data_8bit(0x0E);
//    _gc9_write_data_8bit(0x09);
//    _gc9_write_data_8bit(0x00);
//
//    _gc9_write_command_8bit(0xE1); // Set Gamma
//    _gc9_write_data_8bit(0x00);
//    _gc9_write_data_8bit(0x0E);
//    _gc9_write_data_8bit(0x14);
//    _gc9_write_data_8bit(0x03);
//    _gc9_write_data_8bit(0x11);
//    _gc9_write_data_8bit(0x07);
//    _gc9_write_data_8bit(0x31);
//    _gc9_write_data_8bit(0xC1);
//    _gc9_write_data_8bit(0x48);
//    _gc9_write_data_8bit(0x08);
//    _gc9_write_data_8bit(0x0F);
//    _gc9_write_data_8bit(0x0C);
//    _gc9_write_data_8bit(0x31);
//    _gc9_write_data_8bit(0x36);
//    _gc9_write_data_8bit(0x0F);
//
//    _gc9_write_command_8bit(0x11); // Exit sleep mode
//    HAL_Delay(150);                // Delay 150ms
//
//    _gc9_write_command_8bit(0x29); // Display on
//    HAL_Delay(150);                // Delay 150ms
//
//}

void GC9A01A_Init()
{
	GC9A01A_CS_IDLE;
  GC9A01A_BL_ACTIVE;
  GC9A01A_TE_IDLE;
  GC9A01A_RD_IDLE;
  GC9A01A_CS_ACTIVE;
  gc9a01a_hw_reset();


 _gc9_write_command_8bit(0xFE);

	_gc9_write_command_8bit(0xEF);

	_gc9_write_command_8bit(0xEB);
	_gc9_write_data_8bit(0x14);

	_gc9_write_command_8bit(0x84);
	_gc9_write_data_8bit(0x60);

	_gc9_write_command_8bit(0x85);
	_gc9_write_data_8bit(0xFF);

	_gc9_write_command_8bit(0x86);
	_gc9_write_data_8bit(0xFF);

	_gc9_write_command_8bit(0x87);
	_gc9_write_data_8bit(0xFF);

	_gc9_write_command_8bit(0x8E);
	_gc9_write_data_8bit(0xFF);

	_gc9_write_command_8bit(0x8F);
	_gc9_write_data_8bit(0xFF);

	_gc9_write_command_8bit(0x88);
	_gc9_write_data_8bit(0x0A);

	_gc9_write_command_8bit(0x89);
	_gc9_write_data_8bit(0x21);

	_gc9_write_command_8bit(0x8A);
	_gc9_write_data_8bit(0x00);

	_gc9_write_command_8bit(0x8B);
	_gc9_write_data_8bit(0x80);

	_gc9_write_command_8bit(0x8C);
	_gc9_write_data_8bit(0x01);

	_gc9_write_command_8bit(0x8D);
	_gc9_write_data_8bit(0x03);

	_gc9_write_command_8bit(0xB5);
	_gc9_write_data_8bit(0x08);
	_gc9_write_data_8bit(0x09);
	_gc9_write_data_8bit(0x14);
	_gc9_write_data_8bit(0x08);

	_gc9_write_command_8bit(0xB6);
	_gc9_write_data_8bit(0x00);
	_gc9_write_data_8bit(0x00);

	_gc9_write_command_8bit(0x36);
	_gc9_write_data_8bit(0x48);

	_gc9_write_command_8bit(0x3A);
	_gc9_write_data_8bit(0x05);

	_gc9_write_command_8bit(0x90);
	_gc9_write_data_8bit(0x08);
	_gc9_write_data_8bit(0x08);
	_gc9_write_data_8bit(0x08);
	_gc9_write_data_8bit(0x08);

	_gc9_write_command_8bit(0xBD);
	_gc9_write_data_8bit(0x06);

	_gc9_write_command_8bit(0xBA);
	_gc9_write_data_8bit(0x01);

	_gc9_write_command_8bit(0xBC);
	_gc9_write_data_8bit(0x00);

	_gc9_write_command_8bit(0xFF);
	_gc9_write_data_8bit(0x60);
	_gc9_write_data_8bit(0x01);
	_gc9_write_data_8bit(0x04);

	_gc9_write_command_8bit(0xC3);
	_gc9_write_data_8bit(0x14);

	_gc9_write_command_8bit(0xC4);
	_gc9_write_data_8bit(0x14);

	_gc9_write_command_8bit(0xC9);
	_gc9_write_data_8bit(0x25);

	_gc9_write_command_8bit(0xBE);
	_gc9_write_data_8bit(0x11);

	_gc9_write_command_8bit(0xE1);
	_gc9_write_data_8bit(0x10);
	_gc9_write_data_8bit(0x0e);

	_gc9_write_command_8bit(0xDF);
	_gc9_write_data_8bit(0x21);
	_gc9_write_data_8bit(0x0c);
	_gc9_write_data_8bit(0x02);



	_gc9_write_command_8bit(0xF0);
	_gc9_write_data_8bit(0x45);
	_gc9_write_data_8bit(0x09);
	_gc9_write_data_8bit(0x08);
	_gc9_write_data_8bit(0x08);
	_gc9_write_data_8bit(0x26);
	_gc9_write_data_8bit(0x2A);

	_gc9_write_command_8bit(0xF1);
	_gc9_write_data_8bit(0x43);
	_gc9_write_data_8bit(0x70);
	_gc9_write_data_8bit(0x72);
	_gc9_write_data_8bit(0x36);
	_gc9_write_data_8bit(0x37);
	_gc9_write_data_8bit(0x6F);

	_gc9_write_command_8bit(0xF2);
	_gc9_write_data_8bit(0x45);
	_gc9_write_data_8bit(0x09);
	_gc9_write_data_8bit(0x08);
	_gc9_write_data_8bit(0x08);
	_gc9_write_data_8bit(0x26);
	_gc9_write_data_8bit(0x2A);

	_gc9_write_command_8bit(0xF3);
	_gc9_write_data_8bit(0x43);
	_gc9_write_data_8bit(0x70);
	_gc9_write_data_8bit(0x72);
	_gc9_write_data_8bit(0x36);
	_gc9_write_data_8bit(0x37);
	_gc9_write_data_8bit(0x6F);

	_gc9_write_command_8bit(0xED);
	_gc9_write_data_8bit(0x1B);
	_gc9_write_data_8bit(0x0B);

	_gc9_write_command_8bit(0xAE);
	_gc9_write_data_8bit(0x77);

	_gc9_write_command_8bit(0xCD);
	_gc9_write_data_8bit(0x63);

	_gc9_write_command_8bit(0x70);
	_gc9_write_data_8bit(0x07);
	_gc9_write_data_8bit(0x07);
	_gc9_write_data_8bit(0x04);
	_gc9_write_data_8bit(0x0E);
	_gc9_write_data_8bit(0x0F);
	_gc9_write_data_8bit(0x09);
	_gc9_write_data_8bit(0x07);
	_gc9_write_data_8bit(0x08);
	_gc9_write_data_8bit(0x03);

	_gc9_write_command_8bit(0xE8);
	_gc9_write_data_8bit(0x34);

	_gc9_write_command_8bit(0x62);
	_gc9_write_data_8bit(0x18);
	_gc9_write_data_8bit(0x0D);
	_gc9_write_data_8bit(0x71);
	_gc9_write_data_8bit(0xED);
	_gc9_write_data_8bit(0x70);
	_gc9_write_data_8bit(0x70);
	_gc9_write_data_8bit(0x18);
	_gc9_write_data_8bit(0x0F);
	_gc9_write_data_8bit(0x71);
	_gc9_write_data_8bit(0xEF);
	_gc9_write_data_8bit(0x70);
	_gc9_write_data_8bit(0x70);

	_gc9_write_command_8bit(0x63);
	_gc9_write_data_8bit(0x18);
	_gc9_write_data_8bit(0x11);
	_gc9_write_data_8bit(0x71);
	_gc9_write_data_8bit(0xF1);
	_gc9_write_data_8bit(0x70);
	_gc9_write_data_8bit(0x70);
	_gc9_write_data_8bit(0x18);
	_gc9_write_data_8bit(0x13);
	_gc9_write_data_8bit(0x71);
	_gc9_write_data_8bit(0xF3);
	_gc9_write_data_8bit(0x70);
	_gc9_write_data_8bit(0x70);

	_gc9_write_command_8bit(0x64);
	_gc9_write_data_8bit(0x28);
	_gc9_write_data_8bit(0x29);
	_gc9_write_data_8bit(0xF1);
	_gc9_write_data_8bit(0x01);
	_gc9_write_data_8bit(0xF1);
	_gc9_write_data_8bit(0x00);
	_gc9_write_data_8bit(0x07);

	_gc9_write_command_8bit(0x66);
	_gc9_write_data_8bit(0x3C);
	_gc9_write_data_8bit(0x00);
	_gc9_write_data_8bit(0xCD);
	_gc9_write_data_8bit(0x67);
	_gc9_write_data_8bit(0x45);
	_gc9_write_data_8bit(0x45);
	_gc9_write_data_8bit(0x10);
	_gc9_write_data_8bit(0x00);
	_gc9_write_data_8bit(0x00);
	_gc9_write_data_8bit(0x00);

	_gc9_write_command_8bit(0x67);
	_gc9_write_data_8bit(0x00);
	_gc9_write_data_8bit(0x3C);
	_gc9_write_data_8bit(0x00);
	_gc9_write_data_8bit(0x00);
	_gc9_write_data_8bit(0x00);
	_gc9_write_data_8bit(0x01);
	_gc9_write_data_8bit(0x54);
	_gc9_write_data_8bit(0x10);
	_gc9_write_data_8bit(0x32);
	_gc9_write_data_8bit(0x98);

	_gc9_write_command_8bit(0x74);
	_gc9_write_data_8bit(0x10);
	_gc9_write_data_8bit(0x85);
	_gc9_write_data_8bit(0x80);
	_gc9_write_data_8bit(0x00);
	_gc9_write_data_8bit(0x00);
	_gc9_write_data_8bit(0x4E);
	_gc9_write_data_8bit(0x00);

	_gc9_write_command_8bit(0x98);//add
	_gc9_write_data_8bit(0x3e);
	_gc9_write_data_8bit(0x07);

	_gc9_write_command_8bit(0x99);//add
	_gc9_write_data_8bit(0x3e);
	_gc9_write_data_8bit(0x07);

	_gc9_write_command_8bit(0x35);
	_gc9_write_data_8bit(0x00);


	_gc9_write_command_8bit(0x53);//Write CTRL Display

	_gc9_write_data_8bit(0x24);

	_gc9_write_command_8bit(0x21);
	HAL_Delay(120);
	_gc9_write_command_8bit(0x11);
	HAL_Delay(120);                  //ÑÓÊ±120ms
	_gc9_write_command_8bit(0x29);
	HAL_Delay(20);


	/**************ÉèÖÃÏÔÊ¾µØÖ·*******************/
	//
	//     _gc9_write_command_8bit(0x2A);
	//     _gc9_write_data_8bit(0x00);
	//     _gc9_write_data_8bit(0x00);
	//     _gc9_write_data_8bit(0x00);
	//     _gc9_write_data_8bit(0xEF);
	//     //;
	//     _gc9_write_command_8bit(0x2B);
	//     _gc9_write_data_8bit(0x00);
	//     _gc9_write_data_8bit(0x00);
	//     _gc9_write_data_8bit(0x00);
	//     _gc9_write_data_8bit(0xEF);
	//     //;
	//     _gc9_write_command_8bit(0x2C);
	//     //;

	/**********SLEEP OUT***************/


	_gc9_write_command_8bit(0x11);         //Sleep out
	HAL_Delay(120);                  //ÑÓÊ±120ms
	_gc9_write_command_8bit(0x29);

}
